NUM_PROPOSERS = 2
NUM_ACCEPTORS = 3
NUM_LEARNERS = 1

role Proposer:
    action Init:
        self.proposal = record(n=-1, v=self.__id__)
        self.responses = 0

    action Phase1:
        # Send to a majority of acceptors
        unsent = genericset(acceptors)
        while len(unsent) > NUM_ACCEPTORS // 2:
            a = any unsent
            response = a.prepare(self.n)
            (promise, proposal) = response
            if promise:
                self.responses += 1
            if proposal and proposal.n > self.proposal.n:
                self.proposal = proposal
            unsent.discard(a)

    action Phase2:
        require self.responses > NUM_ACCEPTORS // 2


role Acceptor:
    action Init:
        # accepted proposals
        self.accepted = []

        # The proposal accepted so far with the highest number
        self.highest_accepted = None

        # promises to not accept proposals below this number
        self.n = -1

    # If an acceptor receives a prepare request with number n greater
    # than that of any prepare request to which it has already responded,
    # then it responds to the request with a promise not to accept any more
    # proposals numbered less than n and with the highest-numbered pro-
    # posal (if any) that it has accepted.
    func prepare(n):
        if not self.highest_accepted:
            return (True, None)
        elif self.high_accepted.n < n:
            return (True, self.highest_accepted)
        else:
            # cannot make the promise
            return (False, None)





    atomic func record_chosen_value():
        """Check if a value has been chosen, and record if so"""
        pass

role Learner:
    action Init:
        pass


action Init:
    chosen = genericset()

    proposers = []
    acceptors = []
    learners = []
    for i in range(NUM_PROPOSERS):
        proposers.append(Proposer(n=i))
    for i in range(NUM_ACCEPTORS):
        acceptors.append(Acceptor())
    for i in range(NUM_LEARNERS):
        learners.append(Learner())